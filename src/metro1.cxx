// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "metro1.h"
// generated with xxd -i wavefile.wav > wavefile.h
#include "Tambourine.h"
#include "Closed_Hi_Hat.h"
#include "Low_Wood_Block.h"
#include "Side_Stick.h"

// double-click timeout callback
static void dbl_click_chk(void *v) {
	int *d = (int *)v;
	*d = 0;
}

// 0.5 second timer callback for the display update
static void timer1(void *v) {
	// run the window function
	((MainUI *)(v))->OnTimer();
	// reset timer
	Fl::repeat_timeout(.50, timer1, v);
}


// create the same milliseconds
__time_t GetTickCount() {
	timeval ts;
	gettimeofday(&ts,0);

	return ((__time_t)(ts.tv_sec * 1000 + (ts.tv_usec / 1000)));
}

void MainUI::cb_mainWindow_i(Fl_Double_Window*, void*) {
  OnClose();
}
void MainUI::cb_mainWindow(Fl_Double_Window* o, void* v) {
  ((MainUI*)(o->user_data()))->cb_mainWindow_i(o,v);
}

void MainUI::cb_StartStopButton_i(Fl_Return_Button*, void*) {
  OnStartStopButton();
}
void MainUI::cb_StartStopButton(Fl_Return_Button* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_StartStopButton_i(o,v);
}

void MainUI::cb_m_PresetList_i(Fl_Browser*, void*) {
  OnBrowserClick();
}
void MainUI::cb_m_PresetList(Fl_Browser* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_m_PresetList_i(o,v);
}

void MainUI::cb_m_Volume_i(Fl_Dial*, void*) {
  OnVolChange();
}
void MainUI::cb_m_Volume(Fl_Dial* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_m_Volume_i(o,v);
}

void MainUI::cb_ResetButton_i(Fl_Button*, void*) {
  OnReset();
}
void MainUI::cb_ResetButton(Fl_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_ResetButton_i(o,v);
}

void MainUI::cb_Apply_i(Fl_Button*, void*) {
  OnApply();
}
void MainUI::cb_Apply(Fl_Button* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_Apply_i(o,v);
}

void MainUI::cb_Save_i(Fl_Button*, void*) {
  OnSave();
}
void MainUI::cb_Save(Fl_Button* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void MainUI::cb_Delete_i(Fl_Button*, void*) {
  OnDelete();
}
void MainUI::cb_Delete(Fl_Button* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_Delete_i(o,v);
}

void MainUI::cb_Beep_i(Fl_Round_Button*b, void*) {
  InstCallback(0);
}
void MainUI::cb_Beep(Fl_Round_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_Beep_i(o,v);
}

void MainUI::cb_WoodBlock_i(Fl_Round_Button*b, void*) {
  InstCallback(1);
}
void MainUI::cb_WoodBlock(Fl_Round_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_WoodBlock_i(o,v);
}

void MainUI::cb_SideStick_i(Fl_Round_Button*b, void*) {
  InstCallback(2);
}
void MainUI::cb_SideStick(Fl_Round_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_SideStick_i(o,v);
}

void MainUI::cb_HighHat_i(Fl_Round_Button*b, void*) {
  InstCallback(3);
}
void MainUI::cb_HighHat(Fl_Round_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_HighHat_i(o,v);
}

void MainUI::cb_Tambourine_i(Fl_Round_Button*b, void*) {
  InstCallback(4);
}
void MainUI::cb_Tambourine(Fl_Round_Button* o, void* v) {
  ((MainUI*)(o->parent()->parent()->user_data()))->cb_Tambourine_i(o,v);
}

void MainUI::cb_Set_i(Fl_Button*, void*) {
  OnSet();
}
void MainUI::cb_Set(Fl_Button* o, void* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_Set_i(o,v);
}

MainUI::MainUI() {
  { mainWindow = new Fl_Double_Window(675, 475, "Ugly Metronome 0.2");
    mainWindow->callback((Fl_Callback*)cb_mainWindow, (void*)(this));
    { StartStopButton = new Fl_Return_Button(10, 20, 135, 60, "START");
      StartStopButton->callback((Fl_Callback*)cb_StartStopButton);
    } // Fl_Return_Button* StartStopButton
    { BIG_TEMPO = new Fl_Output(160, 20, 190, 70);
      BIG_TEMPO->textfont(1);
      BIG_TEMPO->textsize(70);
    } // Fl_Text_Display* BIG_TEMPO
    { m_PresetList = new Fl_Browser(10, 175, 530, 290);
      m_PresetList->type(2);
      m_PresetList->callback((Fl_Callback*)cb_m_PresetList);
    } // Fl_Browser* m_PresetList
    { m_Volume = new Fl_Dial(555, 355, 105, 100, "Volume");
      m_Volume->box(FL_GTK_ROUND_UP_BOX);
      m_Volume->maximum(100);
      m_Volume->step(1);
      m_Volume->value(100);
      m_Volume->callback((Fl_Callback*)cb_m_Volume);
      m_Volume->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Dial* m_Volume
    { TimerGroup = new Fl_Group(355, 20, 305, 70, "Timer");
      TimerGroup->box(FL_THIN_DOWN_BOX);
      TimerGroup->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
      { ResetButton = new Fl_Button(359, 55, 70, 30, "Reset");
          ResetButton->callback((Fl_Callback*)cb_ResetButton);
        } // Fl_Button* ResetButton
      { BIG_TIMER = new Fl_Output(435, 25, 220, 60);
        BIG_TIMER->textfont(1);
        BIG_TIMER->textsize(40);
      } // Fl_Output* BIG_TIMER
      TimerGroup->end();
    } // Fl_Group* TimerGroup
    { m_EditStop = new Fl_Input(110, 120, 95, 30, "Stop Tempo");
      m_EditStop->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Input* m_EditStop
    { m_EditTime = new Fl_Input(210, 120, 95, 30, "Time");
      m_EditTime->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Input* m_EditTime
    { m_EditNote = new Fl_Input(310, 120, 265, 30, "Note");
      m_EditNote->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Input* m_EditNote
    { Fl_Button* o = new Fl_Button(580, 110, 60, 25, "Apply");
      o->callback((Fl_Callback*)cb_Apply);
    } // Fl_Button* o
    { Fl_Button* o = new Fl_Button(580, 140, 60, 25, "Save");
      o->callback((Fl_Callback*)cb_Save);
    } // Fl_Button* o
    { m_EditStart = new Fl_Input(10, 120, 95, 30, "Start");
      m_EditStart->labeltype(FL_NO_LABEL);
      m_EditStart->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Input* m_EditStart
    { Fl_Button* o = new Fl_Button(545, 175, 60, 25, "Delete");
      o->callback((Fl_Callback*)cb_Delete);
    } // Fl_Button* o
    { Gr_Instruments = new Fl_Group(545, 230, 120, 95, "Instruments");
      Gr_Instruments->box(FL_THIN_DOWN_BOX);
      { Beep = new Fl_Round_Button(550, 235, 70, 15, "Beep");
        Beep->down_box(FL_ROUND_DOWN_BOX);
        Beep->callback((Fl_Callback*)cb_Beep);
      } // Fl_Round_Button* Beep
      { WoodBlock = new Fl_Round_Button(550, 252, 70, 15, "Wood Block");
        WoodBlock->down_box(FL_ROUND_DOWN_BOX);
        WoodBlock->callback((Fl_Callback*)cb_WoodBlock);
      } // Fl_Round_Button* WoodBlock
      { SideStick = new Fl_Round_Button(550, 270, 70, 15, "Side Stick");
        SideStick->down_box(FL_ROUND_DOWN_BOX);
        SideStick->callback((Fl_Callback*)cb_SideStick);
      } // Fl_Round_Button* SideStick
      { HighHat = new Fl_Round_Button(550, 287, 70, 15, "High Hat");
        HighHat->down_box(FL_ROUND_DOWN_BOX);
        HighHat->callback((Fl_Callback*)cb_HighHat);
      } // Fl_Round_Button* HighHat
      { Tambourine = new Fl_Round_Button(550, 305, 70, 15, "Tambourine");
        Tambourine->down_box(FL_ROUND_DOWN_BOX);
        Tambourine->callback((Fl_Callback*)cb_Tambourine);
      } // Fl_Round_Button* Tambourine
      Gr_Instruments->end();
    } // Fl_Group* Gr_Instruments
    { Fl_Button* o = new Fl_Button(10, 90, 95, 30, "Set Tempo");
      o->callback((Fl_Callback*)cb_Set);
    } // Fl_Button* o
    { Fl_Box* o = new Fl_Box(13, 150, 35, 38, "Start");
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(13+75, 150, 35, 38, "Stop");
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(13+75+75, 150, 35, 38, "Ramp");
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* o
    { Fl_Box* o = new Fl_Box(13+75+75+75, 150, 35, 38, "Note");
      o->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* o
     mainWindow->end();
  } // Fl_Double_Window* mainWindow
}

void MainUI::init() {
  // initialize variables before show
  	m_EditStart->value("120");
  	m_EditStop->value("120");
  	m_EditTime->value("0");
  	m_EditNote->value("");
  	m_Volume->value(80);
  	// create Jack
  	if (BeatInit()) exit (0);
  	// null connection and wave files
  	BeatSetJackClient(0, NULL);
  	BeatSetJackClient(1, NULL);
  	SetWave(0);
  	BeatSetVolume((float)m_Volume->value());

 	// read data file
  	ReadDat();
  	// set up columns in browser
  	static int widths[] = { 75, 75, 75, 250, 0 };               // widths for each column
  	m_PresetList->column_widths(widths);
  	m_PresetList->column_char('\t');                            // tabs as column delimiters
	m_RunState = 0;
  	// connect and start jack
  	BeatConnect();
 	// start the timer here
	Fl::add_timeout(0.5, timer1, (void *)this);

}

void MainUI::show() {
  mainWindow->show(0,NULL);
}

void MainUI::OnClose() {
  //KillTimer - it will just elapse
  	//free Jack
  	WriteDat();
  	//close Jack
  	BeatClose();
  	exit(0);
}

void MainUI::OnStartStopButton() {
  if (m_RunState == 1) {
  	m_RunState = 0;
  	// turn off transport
  	BeatRun(0);
  	StartStopButton->label("START");
  } else {
  	m_RunState = 1;
  	m_TimerStart = GetTickCount();
  	// turn on transport
  	BeatRun(1);
  	StartStopButton->label("STOP");
  }
}

void MainUI::OnDelete() {
  int i;
  
  	i=m_PresetList->size();
  	if (i == 0) return;
  	for (i=1; i<=m_PresetList->size(); i++) {
  		if (m_PresetList->selected(i)) {
  			m_PresetList->remove(i);
  			// select the line after
  			if (m_PresetList->size() > 0) m_PresetList->select(i);
  			return;
  		}
  	}
}

void MainUI::OnTimer() {
	static int odd;
  	long f;
  	char b[32];

  	__time_t elapsed;
  	// display tempo every  1 second
  	if (odd == 0) {
  		f = BeatGetBPM();
  		if (f == 0) return;
  		sprintf(b, "%ld", f);
  		BIG_TEMPO->value(b);
  	}
  	odd = (odd + 1) & 2;
  
  	// display timer every 0.5 seconds
  	if (m_RunState) {
  		elapsed = GetTickCount() - m_TimerStart;
  		elapsed /= 1000;
  		sprintf(b,"%02ld:%02ld:%02ld", (unsigned long)(elapsed / 3600), (unsigned long)(elapsed % 3600)/60, (unsigned long)elapsed % 60);
  		BIG_TIMER->value(b);
  	}
}

void MainUI::OnReset() {
  m_TimerStart = GetTickCount();
}

void MainUI::OnVolChange() {
  // update the volume
  	BeatSetVolume((float)m_Volume->value());
}

void MainUI::OnApply() {
	long i_start, i_stop, i_ramp;
	i_start = atol(m_EditStart->value());
	i_stop = atol(m_EditStop->value());
	i_ramp = atol(m_EditTime->value());
    // set the tempo the the start tempo immediately
  	Validate(&i_start, &i_stop, &i_ramp);
  	BeatSetTempo((float)i_start, (float)i_stop, i_ramp);
}

void MainUI::InstCallback(int i) {
  if (m_RunState == 1) OnStartStopButton();
  SetWave(i);
}

void MainUI::SetWave(int res) {
  	unsigned char *pRc;
  
  	// the waves are headers
  	switch (res) {
  	case 1:
  		pRc = Low_Wood_Block_wav;
  		break;
  	case 2:
  		pRc = Side_Stick_wav;
  		break;
  	case 3:
  		pRc = Closed_Hi_Hat_wav;
  		break;
  	case 4:
  		pRc = Tambourine_wav;
  		break;
  	default: // beep
  		pRc = NULL;
  	}
	if (pRc) {
		// get the size of the wave file
		unsigned char *szw = (unsigned char *)pRc;
		signed short *bw = (signed short *)&szw[44]; // data bits
		unsigned int *length = (unsigned int *)&szw[40]; // length

		if (0 != strncmp((const char *)&szw[36], "data", 4)) {
		} else {
			if ((*length > 200000) || (*length < 0)) {
			} else {
				BeatLoad(bw, *length);
			  	SetInstrumentButtons(res);
				return;
			}
		}
	}
	// load default bing
  	BeatLoad(NULL, 0);
  	// reset radio buttons
  	SetInstrumentButtons(res);
}

void MainUI::SetInstrumentButtons(int i) {
	Beep->value((i == 0) ? 1 : 0);
	WoodBlock->value((i == 1) ? 1 : 0);
	SideStick->value((i == 2) ? 1 : 0);
	HighHat->value((i == 3) ? 1 : 0);
	Tambourine->value((i == 4) ? 1 : 0);
}

int MainUI::ReadDat() {
  	FILE *f;
  	char inbuf[128];
  	int def_wave;
	float def_vol;
  	long i_start, i_stop, i_ramp;
  	long def_tempo, def_stop, def_ramp;
  	char note[128];
  	char def_note[128];
  	char *lnote;

  	def_wave=0;
  	def_vol = 100;
  	def_tempo = 120;
  	def_stop = 120;
  	def_note[0] = 0;
   	if (NULL == datfile) return 1;
  	// maybe the file doesn't exist, so return quietly
  	if (NULL == (f=fopen(datfile,"r"))) return 0;
  	while (!feof(f)) {
  		inbuf[0] = 0;
  		fgets(inbuf,128,f);
  		switch(inbuf[0]) {
  		case 'I':
  			// next character is instrument
  			def_wave = (int)(inbuf[1]-'0');
  			if (def_wave < 0) def_wave = 0;
  			if (def_wave > 4) def_wave = 4;
 			break;
  		case 'D':
  			note[0]=0;
  			sscanf(&inbuf[1],"%ld\t%ld\t%ld",&i_start,&i_stop,&i_ramp);
  			Validate(&i_start, &i_stop, &i_ramp);
  			lnote = strchr(inbuf,'$');
  			if (lnote) strncpy(def_note, ++lnote, 99); else note[0]=0;
  			strtok(def_note, "\n\r");
  			def_tempo = i_start;
  			def_stop = i_stop;
  			def_ramp = i_ramp;
  			break;
  		case 'P':
  			note[0]=0;
  			sscanf(&inbuf[1],"%ld\t%ld\t%ld",&i_start,&i_stop,&i_ramp);
  			Validate(&i_start, &i_stop, &i_ramp);
  			lnote = strchr(inbuf,'$');
  			if (lnote) strncpy(note, ++lnote, 99); else note[0]=0;
  			strtok(note, "\n\r");
  			sprintf(inbuf,"%ld\t%ld\t%ld\t%s",i_start,i_stop,i_ramp,note);
  			m_PresetList->add(inbuf);
  			break;
  		case 'V':
  			sscanf(&inbuf[1], "%f", &def_vol);
  			break;
  		case 'A':
  			BeatSetJackClient(0, strtok(&inbuf[1], "\n"));
  			break;
  		case 'B':
  			BeatSetJackClient(1, strtok(&inbuf[1], "\n"));
  			break;
 		}
 	}
  	fclose(f);
	if (def_vol < 0) def_vol = 0;
	if (def_vol > 100) def_vol = 100;
	m_Volume->value(def_vol);
	BeatSetVolume((float)m_Volume->value());
	BeatSetTempo((float)def_tempo, (float)def_stop, def_ramp);
	sprintf(note, "%ld", def_tempo);
	m_EditStart->value(note);
	sprintf(note, "%ld", def_stop);
	m_EditStop->value(note);
	sprintf(note, "%ld", def_ramp);
	m_EditTime->value(note);
	m_EditNote->value(def_note);
	sprintf(note, "%ld", BeatGetBPM());
	BIG_TEMPO->value(note);
  	// if not wave set after this procedure, set radio button to beep
	SetWave(def_wave);

  	return 0;
}

int MainUI::WriteDat() {
    FILE *f;
  	int i;
  	char c[256];
  	char note[256];
  	char *lnote;
  	long i_start, i_stop, i_ramp;

  	if (NULL == datfile) return 1;
  	// maybe the file doesn't exist, so return quietly
  	if (NULL == (f=fopen(datfile,"w"))) {
  		fl_alert("Could not open data file %s for writing", datfile);
  		return 1;
  	}
  	fprintf(f,"#Edit this file at your own risk. When in doubt, delete this file and start again.\n");
  	fprintf(f,"#Syntax:\n");
  	fprintf(f,"#In: Set instrument to n\n");
  	fprintf(f,"#Vv: volume (0-100)\n");
  	fprintf(f,"#Dstart\\tstop\\ttime\\t$note: default\n");
  	fprintf(f,"#Pstart\\tstop\\ttime\\t$note: presets\n");
  	fprintf(f,"#Aclient name: jack connection name for channel A (optional)\n");
 	fprintf(f,"#Bclient name: jack connection name for channel B (optional)\n");
   	i=0;
	if (WoodBlock->value() != 0) i=1;
	else if (SideStick->value() != 0) i=2;
	else if (HighHat->value() != 0) i=3;
	else if (Tambourine->value() != 0) i=4;
  	fprintf(f, "I%d\n", i);
  	fprintf(f, "V%f\n", (float)m_Volume->value());
  	fprintf(f, "D%ld\t%ld\t%ld\t$%s\n", atol(m_EditStart->value()),atol(m_EditStop->value()),atol(m_EditTime->value()),m_EditNote->value());
  	for (i=1; i<=m_PresetList->size(); i++) {
  		// the note must have a $ prefix
  		strncpy(note, m_PresetList->text(i), 256);
		sscanf(note,"%ld\t%ld\t%ld%s",&i_start,&i_stop,&i_ramp,c);
		lnote = strstr(note,c);
		sprintf(c,"%ld\t%ld\t%ld\t$%s",i_start,i_stop,i_ramp,lnote);
  		fprintf(f, "P%s\n", c);
  	}
  	// get jack clients
  	BeatGetJackClient(0, c, 64);
  	if (c[0]) fprintf(f, "A%s\n", c);
	BeatGetJackClient(1, c, 64);
	if (c[0]) fprintf(f, "B%s\n", c);
fclose(f);
  	return 0;
}

int MainUI::Validate(long *i_start, long *i_stop, long *i_ramp) {
	char fix[16];
  int beepflag = 0;
  	if (*i_start > MAX_TEMPO) {
  		beepflag++; 
  		*i_start = MAX_TEMPO;
  		fl_alert("%s","Max Tempo Exceeded.");
  		sprintf(fix, "%d", MAX_TEMPO);
  		m_EditStart->value(fix);
  	}
  	if (*i_start < MIN_TEMPO) {
  		beepflag++; 
  		*i_start = MIN_TEMPO;
  		fl_alert("%s","Min Tempo Too Low");
  		sprintf(fix, "%d", MIN_TEMPO);
  		m_EditStart->value(fix);
  	}
  	if (*i_stop > MAX_TEMPO) {
  		beepflag++; 
  		*i_stop = MAX_TEMPO;
  		fl_alert("%s","Max Tempo Exceeded.");
  		sprintf(fix, "%d", MAX_TEMPO);
  		m_EditStop->value(fix);
  	}
  	if (*i_stop < MIN_TEMPO) {
  		beepflag++; 
  		*i_stop = MIN_TEMPO;
  		fl_alert("%s","Min Tempo Too Low");
  		sprintf(fix, "%d", MIN_TEMPO);
  		m_EditStop->value(fix);
  	}
  	if (*i_ramp < 0) {
  		beepflag++; 
  		*i_ramp = 0;
  		fl_alert("%s","Invalid Ramp Time.");
  		m_EditTime->value("0");
  	}
  	if (*i_stop > MAX_RAMP) {
  		beepflag++; 
  		*i_ramp = MAX_RAMP;
  		fl_alert("%s","Ramp Time too High.");
  		sprintf(fix, "%d", MAX_RAMP);
  		m_EditTime->value(fix);
  	}
  	return beepflag;
}

void MainUI::OnSave() {
	char tabbedstr[256];
	long i_start, i_stop, i_ramp;
	i_start = atol(m_EditStart->value());
	i_stop = atol(m_EditStop->value());
	i_ramp = atol(m_EditTime->value());
	// set the tempo the the start tempo immediately
  	Validate(&i_start, &i_stop, &i_ramp);
  	sprintf(tabbedstr, "%ld\t%ld\t%ld\t%s", i_start,  i_stop, i_ramp, m_EditNote->value());
  	m_PresetList->add(tabbedstr);
}

void MainUI::OnBrowserClick() {
  	int i;
  	char *es,*esp,*et,*en;
  	char s[256];
  	
  	// detect double click
  	if (this->double_clicked > 0) {
  		i = m_PresetList->value();
  		if (i > 0) {
  			strncpy(s, m_PresetList->text(i), 256);
  			es = strtok(s,"\t");
  			esp = strtok(NULL, "\t");
  			et = strtok(NULL, "\t");
 			en = strtok(NULL, "\t");
 	  		m_EditStart->value(es);
 	  		m_EditStop->value(esp);
 	  		m_EditTime->value(et);
 	  		m_EditNote->value(en);
 	  	  	OnApply(); // also validates
   		}
	} else {
  		// start double-click timer
  		this->double_clicked++;
  		Fl::add_timeout(0.25, dbl_click_chk, (void *)&double_clicked);
  	}
}

void MainUI::OnSet() {
	long i_start, i_stop, i_ramp;
	i_start = atol(m_EditStart->value());
	i_stop = atol(m_EditStop->value());
	i_ramp = 0;
	// set the tempo the the start tempo immediately
  	Validate(&i_start, &i_stop, &i_ramp);
  	// set the start tempo immediately
   	BeatSetTempo((float)i_start, (float)i_start, i_ramp);
}
